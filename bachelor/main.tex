% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\graphicspath{ {img/} }

\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\begin{document}

\Intro
В данной работе была реализована генерация алгебраических типов данных языка программирования \lstinline{Haskell} 
по исходным данным в формате \lstinline{JSON}.

В качестве основных инструментов для реализации поставленной задачи используются 
библиотека \lstinline{Data.Aeson}~\cite{aeson} и расширение \lstinline{Template Haskell}~\cite{tempHaskell}. Генерация 
производится с помощью рекурсивного прохода по абстрактному синтаксическому дереву (далее --- AST) и 
накопление результатов обхода в монаде \lstinline{State} ~\cite{stateM}.

Ключевыми моментами в реализации программы являются:

\begin{itemize}
  \item Получение AST по исходному \lstinline{JSON}.
  \item Преобразование AST в структруру для генерации алгебраического типа.
  \item Вклейка ("splicing") сгенерированного типа данных в код.
\end{itemize}

\chapter{Предварительные сведения}

\section{JavaScript Object Notation}

JSON (\lstinline{JavaScript Object Notation})~\cite{jsonStandart} --- простой формат обмена данными, основанный на подмножестве языка программирования \lstinline{JavaScript}. При этом независим и может использоваться практически любым языком программирования. Файл в формате \lstinline{JSON} представляет неупорядоченное множество пар ключ-значение, значения которого могут состоят из:  

\begin{itemize}
  \item объектов (выделяются \{ ... \})
  \item массивов (выделяются [ ... ])
  \item строк
  \item логических выражений (true | false)
  \item null-значений
\end{itemize}

\begin{ListingEnv}[H]
\begin{Verb}
{     
    "firstName": "John",
    "lastName" : "Smith",
    "age" : 25
}
\end{Verb}
\caption{Пример данных в формате JSON}
\label{listing:jsonExample}
\end{ListingEnv}

Структуру хорошо можно выразить по средствам схем, представленным на рисунках ~\ref{fig:objectGr}, ~\ref{fig:arrayGr} и ~\ref{fig:valueGr}.

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{object}
\caption{\label{fig:objectGr}Объект}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{array}
\caption{\label{fig:arrayGr}Массив}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{value}
\caption{\label{fig:valueGr}Значение}
\end{figure}

\section{Алгебраические типы данных}

Алгебраические типы данных (далее --- АТД) --- вид составных типов, представленных типом-произведением, типом-суммой, либо типом-суммой типов-произведений.~\cite{haskellGreatGood} Последний вариант хорошо илюстрируется примером двоичного дерева:

\begin{lstlisting}[language=Haskell]
data Tree a = Leaf a
          | Node (Tree a) (Tree a)
\end{lstlisting}

В примере \lstinline{Tree} является конструктором типа с одним типовым параметром. \lstinline{Leaf} и \lstinline{Node} --- конструкторы значений. 

Также есть еще один вариант определения типа, называемый синтаксис записи с именованными полями:

\begin{lstlisting}[language=Haskell]
data Person = Person { firstName :: String
                       , lastName :: String
                       , age :: Int }
\end{lstlisting}

Вместо простого перечисления типов, мы создаем некую структуру и наполяем ее полями и их значениями. Главная выгода –-- такой синтаксис генерирует функции для извлечения полей. Также создается удобство чтения и понимая типа данных. Такие типы напоминают своей структурой \lstinline{JSON}-файлы. 

\section{Монада State}

Монада \lstinline{State} применима, когда имеется некоторое состояние, которое мы постоянно изменяем. Cамое интересное, что при таком способе мы трансформируем состояние, но при этом не теряем "чистоту" функций. 

\subsection{Control.Monad.State}

Модуль Control.Monad.State~\cite{stateControl} определяет тип, оборачивающий вычисление с состоянием:

\begin{lstlisting}[language=Haskell]
newtype State s a = State {runState :: s -> (a,s) }
\end{lstlisting} 

Как видно из определения, вычисление в монаде State возвращает некоторый результат, при этом меняет состояние, при необходимости. Операции с состояними реализованы следующими функциями: \lstinline{get}(получает состояние) и \lstinline{put}(изменяет состояние на новое). В листинге~\ref{listing:stateGetPut} приведен простой пример, хорошо демонстрирующий возможности монады \lstinline{State}.

\begin{ListingEnv}[H]
\begin{Verb}
tick :: State Int Int
tick = do n <- get
	  put (n+1)
          return n

ghci> runState tick 3
(3,4)
\end{Verb}
\caption{Пример использования монады State}
\label{listing:stateGetPut}
\end{ListingEnv}

Также модуль содержит полезные функции для работы с состояниями. Самые важные представлены в листинге~\ref{listing:stateFunc}. Функции с постфиксом -State отличаются типом возвращаемого значения. Необходимое поведение можно выбрать исходя из сигнатуры.

\begin{ListingEnv}[H]
\begin{Verb}
modify :: MonadState s m => (s -> s) -> m ()

execState:: State s a -> s -> s

runState:: State s a -> s -> (a, s)

evalState:: State s a -> s -> a
\end{Verb}
\caption{Функции модуля Control.Monad.State}
\label{listing:stateFunc}
\end{ListingEnv}

Например, функция \lstinline{modify} преобразует внутреннее состояние функцией, которую получает на вход. Можно реализовать код листинга ~\ref{listing:stateGetPut} через \lstinline{modify} (листинг~\ref{listing:modifyState}).

\begin{ListingEnv}[H]
\begin{Verb}
tick :: State Int Int
tick = do modify (+1)
          return n

ghci> runState tick 3
(3,4)
\end{Verb}
\caption{Функция modify модуля Control.Monad.State}
\label{listing:modifyState}
\end{ListingEnv}
	
\section{Библиотека Data.Aeson}
\label{sec:secAeson}

\subsection{Общий способ}

\lstinline{Data.Aeson} --- библиотека для работы с файлами в формате \lstinline{JSON}, написанная на языке \lstinline{Haskell}. В библиотеке используются два основных класса типов --- \lstinline{FromJSON} и \lstinline{ToJSON}.~\cite{aesonEx} Типы, имеющие возможность кодирования/декодирования, должны быть экземплярами классов \lstinline{FromJSON}, \lstinline{ToJSON}. Самый простой способ использования библиотеки --- определить тип данных и экземпляры \lstinline{FromJSON}, \lstinline{ToJSON}. 

Существует возможность прописать экземпляры для кодирования/ декодирования по умолчанию, благодаря инструкции компилятора \lstinline{LANGUAGE} и экземпляру \lstinline{Generic}. Рассмотрим листинг~\ref{listing:genericData}, демонстрирующий данную возможность с условным типом данных 

\begin{ListingEnv}[H]
\begin{Verb}
instance ToJSON DataName

instance FromJSON DataName
\end{Verb}
\caption{Создание экземпляров по умолчанию}
\label{listing:genericData}
\end{ListingEnv}

\lstinline{Data.Aeson} имеет свой собственный тип для представления конвертируемого \lstinline{JSON}-файла. Этот тип называется \lstinline{Value} и имеет 6 конструкторов значения:

\begin{ListingEnv}[H]
\begin{Verb}
data Value
  = Object Object
  | Array Array
  | String Text
  | Number Scientific
  | Bool Bool
  | Null
\end{Verb}
\caption{Конструкторы Value}
\label{listing:value}
\end{ListingEnv}

\subsection{Работа с AST}

\lstinline{Aeson} позволяет получить абстрактное синтаксическое дерево по \lstinline{JSON}. Это бывает полезно, когда неизвестно какой тип данных 
соотвествует входному файлу. Имея AST, можно написать функцию для его обхода.~\cite{aesonEx}

В качестве примера рассмотрим получение AST для двух случаев: простой (листинг~\ref{listing:astGetSimple}) и более сложный со вложенными объектами (листинг~\ref{listing:astGetComp}).

\begin{ListingEnv}[H]
\begin{Verb}
decode :: FromJSON a => ByteString -> Maybe a

ghci> decode "{\"foo\": 123}" :: Maybe Value
Just (Object (fromList [("foo",Number 123)]))
\end{Verb}
\caption{JSON без вложенных объектов}
\label{listing:astGetSimple}
\end{ListingEnv}

\begin{ListingEnv}[H]
\begin{Verb}
ghci> decode "{\"foo\": [\"abc\",\"def\"]}" :: Maybe Value
Just (Object (fromList [("foo",Array (fromList [String "abc", 
                                               String "def"]))]))
\end{Verb}
\caption{JSON со вложенными объектами}
\label{listing:astGetComp}
\end{ListingEnv}

Помимо простого кодирования/декодирования \lstinline{JSON} она также позволяет удобным образом писать сериализаторы и десериализаторы для произвольных типов.

\section{Template Haskell}

\lstinline{Template Haskell} --- это расширение языка \lstinline{Haskell}, реализующее средства для метапрограммирования.~\cite{extensionHub} Оно позволяет использовать Haskell как язык управления и как управляемый язык. Так как работа ведется с расширением, то в исходник необходимо добавить директиву:

\begin{lstlisting}[language=Haskell]
{-# LANGUAGE TemplateHaskell #-}.
\end{lstlisting}

\subsection{Монада Q}

Монада \lstinline{Q} оборачивает значения типов, предназначенных для последующей генерации других конструкций на языке \lstinline{Haskell}. Такие типы полностью удовлетворяют синтаксису языка и представляет собой абстрактное синтаксическое дерево кода: тип \lstinline{Exp} для генерации выражений, \lstinline{Dec} --- для объявлений, \lstinline{Lit} - для литералов и т.д.~\cite{thSyntax}

\subsection{Модуль Language.Haskell.TH.Syntax}

Модуль Language.Haskell.TH.Syntax

Тип \lstinline{Exp} определен в модуле \lstinline{Language.Haskell.TH.Syntax}~\cite{coverHaskell} и  \lstinline{Exp} имеет около 25 конструкторов значения. В листинге ~\ref{listing:expConstr} представлены только некоторые.  

\begin{ListingEnv}[H]
\begin{Verb}
data Exp
       = VarE Name
       | AppE Exp Exp
       | MultiIfE [(Guard, Exp)]
       | CondE Exp Exp Exp
       | ...
\end{Verb}
\caption{Конструкторы Exp}
\label{listing:expConstr}
\end{ListingEnv}

\subsection{Вклейка(splicing)}

Вклейка кода производится оператором  \lstinline{\$(...)}, который разворачивает шаблон с данным параметром в обычный \lstinline{Haskell} код во время компиляции и вклеивает его на то же место. Важно, чтобы между скобками и оператором \lstinline{\$} не было пробелов. Также есть ограничение по использованию вклейки: ее можно использовать только из другого модуля, т.е. нельзя в одном модуле прописать шаблон и сразу же его использовать.

Вклейка может использоваться в:

\begin{itemize}
  \item выражениях (выражение должно иметь тип Q Exp).
  \item объявлениях верхнего уровня (выражение должно иметь тип Q [Dec]).
  \item типах (выражение должно иметь тип Q Type).
\end{itemize}

\chapter{Генерация АТД по JSON-файлу}

\section{Выбор средств для реализации}

Изначально, при реализации задачи, поставленной во Введении, стоял выбор между несколькими средствами. Рассмотрим каждый из них.

\subsection{Расширение к языку Haskell}

Такая реализация дает некоторые преимущества в простоте использования (необходимо просто прописать директиву, добавляющую это расширение), но при этом тяжела в реализации, так как для ее осуществления требуется менять исходные коды комплятора  \lstinline{GHC}. При этом, в данной реализации не хватало бы наглядности и синтаксис отличался бы от привычного.

\subsection{Написание парсера}
Данное решение позволяет использовать стандартные методы и наработки связанные с парсерами. При этом, можно вывести готовый алгебраический тип данных. Но после этого возникает проблема: как использовать этот тип сразу же без дополнительных манипуляций.   	

\subsection{Template Haskell}
Такой подход оказался предпочтительнее остальных. Во-первых, он решает проблемы других подходов, в том числе позволяет использовать сгенерированный тип без дополнительных накладных ресурсов и средств. Во-вторых, предоставляет возможность генерировать данные  и "на лету" их использовать. Для получение AST будет использоваться ранее упомянутая библиотека \lstinline{Data.Aeson}. В добавление этому эта идея кажется более интересной с точки зрения практической реализации. 

\section{Программная реализация генератора АТД}

\subsection{Применение DataD (Template Haskell)}

Программная реализация средставами \lstinline{Template Haskell} генерирует объявление типов данных: используется конструктор значения \lstinline{DataD} типа \lstinline{Dec}(листинг ~\ref{listing:dataDTH}). \lstinline{DataD} является конструктором значения \lstinline{Dec}. \lstinline{Cxt} определяет классы типов. 

\lstinline{Name} --- абстрактный тип, представляющий имена в синтаксическом дереве. Используется для определения имени полей и конструкторов. Функция \lstinline{mkName}(листинг~\ref{listing:mkName} создаёт значение типа \lstinline{Name} из обычной строки (\lstinline{String}), с её содержанием в качестве имени.

\begin{ListingEnv}[H]
\begin{Verb}
Dec 
   = DataD Cxt Name [TyVarBndr] [Con] Cxt
   | ...
\end{Verb}
\caption{Конструктор значения типа Dec}
\label{listing:dataDTH}
\end{ListingEnv} 

\begin{ListingEnv}[H]
\begin{Verb}
mkName :: String -> Name
\end{Verb}
\caption{Особенность: чистота функции mkName}
\label{listing:mkName}
\end{ListingEnv} 

В коде реализации мы используем тип из листинга~\ref{listing:dataDTH} для вклейки типа в объявлениях верхнего уровня. \lstinline{RecC} дает понять, что сгенерированный тип должен представлять собой запись с именованными полями. Использование класса типов \lstinline{Generic} пригодится в будущем, когда будут генерироваться шаблоны \lstinline{FromJSON} и \lstinline{ToJSON} ,описанные в разделе~\ref{sec:secAeson}.

\begin{ListingEnv}[H]
\begin{Verb}
DataD
     []
     (mkName $ firstLetterToUpper key')
     []
     [ RecC (mkName $ firstLetterToUpper key')  (result) ]
     [mkName "Generic", mkName "Show", mkName "Eq"]
\end{Verb}
\caption{Генерация Data в тексте программы}
\label{listing:dataDTHjson}
\end{ListingEnv} 

\section{Использование монады State}

Для аккумуляции типов \lstinline{Dec} был необходим аналог глобальной переменной в императивных языках программирования. Понятное дело, что в функциональных языках нет таких средств в чистом виде. Но похожего поведения можно добится монадой \lstinline{State}:

\begin{lstlisting}[language=Haskell]
State [Dec] ()
\end{lstlisting}

Накапливать типы для генерации мы будем с помощью функции \lstinline{modify} из модуля \lstinline{Control.Monad.State}. Но существует проблема: каждый раз, когда мы будем использовать \lstinline{modify}, будет порождаться новый экземпляр типа \lstinline{State [Dec] ()}, то есть условно не будет глобальной переменной, в которую собираются все необходимые данные. 

Для того, чтобы решить возникшую проблему нам необходима монадическая свертка по ключу и значению (листинг~\ref{listing:foldMonad}). Свертка реализована с помощью \lstinline{foldlM} из модуля \lstinline{Data.Foldable} и функции \lstinline{uncurry} (преобразует каррированную функцию в функцию, принимающую пару).

\begin{ListingEnv}[H]
\begin{Verb}
import qualified Data.HashMap.Strict as StrHash
import qualified Data.Foldable    as FB

foldlWithKeyM :: (Monad m) => (b -> k -> a -> m b) -> b ->
                                       StrHash.HashMap k a -> m b
foldlWithKeyM f b = FB.foldlM f' b . StrHash.toList
  where f' a = uncurry (f a)
\end{Verb}
\caption{foldlWithKeyM}
\label{listing:foldMonad}
\end{ListingEnv} 

\section{Основная часть}

Основной функцией, которая объединяет воедино получение AST библиотекой Data.Aeson, обход этого дерева и аккумуляцию типов Dec, является функция 

Функция которая проходит по Hashmap имеет сигнатуру:

\begin{lstlisting}[language=Haskell]
convertFields:: MonadState [Dec] m => Value -> 
                                        m [(Name, Strict, Type)]
\end{lstlisting}

Функция convertFields как раз порождает именованные поля для типа данных.

\chapter{Пример практического использования}

\lstinline{Git}-репозиторий с исходным кодом на языке \lstinline{Haskell} доступен по адресу ~\cite{diploma}. Тестовые примеры запускались на компиляторе \lstinline{GHC} версии \lstinline{7.10.3}. Версия библиотеки \lstinline{Data.Aeson} --- \lstinline{0.10.0.0}, \lstinline{Template Haskell} --- \lstinline{2.10.0.0}.

\section{Отладка программ в GHC}

Компилятор \lstinline{GHC} предоставляет мощные инструменты для отладки программы. ~\cite{debugGHC} Например, можно ставить контрольные точки, получать подробное описание ошибок, генерировать полезные структуры, смотреть на AST и т.д. Для этого используются флаги компилятору. 

Полезным флагом для программы, использующей \lstinline{Template Haskell} служит \lstinline{-ddump-splices}. Его средствами организован вывод полученного из шаблона выражения, либо ошибки (информативное сообщение).

\begin{ListingEnv}[H]
\begin{Verb}
on.hs:8:3-17: Splicing declarations
    getDataFromJSON
  ======>
    data JSONData
      = JSONData {name :: String}
      deriving (Generic, Show, Eq)
\end{Verb}
\caption{Запуск отладчика с флагом -ddump-splices}
\end{ListingEnv}

\section{Простой пример}
Для начала будет рассмотрен простой пример. На вход программе подается простой \lstinline{JSON}, т.е. без вложенных объектов (листинг ~\ref{listing:json1}).

\begin{ListingEnv}[H]
\begin{Verb}
{
    "name" : "Joe",
    "age" : 25,
    "avg" : 4,
    "arr" : [1,2,3]
}
\end{Verb}
\label{listing:json1}
\end{ListingEnv}

В итоге мы получаем тип данных с именованными полями, полностью соответсвующий постановке задачи:

\begin{lstlisting}[language=Haskell]
data JSONData 
        = JSONData {arr :: [Float]
                    name :: String,
                    age :: Float,
                    avg :: Float}
          deriving (Show, Eq, Generic)
\end{lstlisting}

\section{Более сложный пример}

На вход программе подается \lstinline{JSON} со вложенным объектом. (Листинг ~\ref{listing:json2})  Интерес представляет то, как он будет представлен. 

\begin{ListingEnv}[H]
\begin{Verb}
{
    "name" : "Joe",
    "age" : 25,
    "avg" : 4,
    "arra" : 
             {
                 "fg" : "JSONTest"  
             }
}
\end{Verb}
\label{listing:json2}
\end{ListingEnv}

После выполнения программы мы получаем 2 типа данных, что полностью соответствует заявленным требованиям к программе. Первый тип в своем определении использует второй. 

\begin{lstlisting}[language=Haskell]
data JSONData
      = JSONData {name :: String,
                  arra :: Arra,
                  age :: Float,
                  avg :: Float}
        deriving (Show, Eq, Generic)

data Arra
      = Arra {fg :: String}
        deriving (Show, Eq, Generic)            
\end{lstlisting}

\chapter{Варианты дальнейшего применения}

Соответственно, один из вариантов использования - получать JSON-файл из базы данных и далее преобразовывать его в тип данных на языке Haskell. Далее можно прописать полезные функции для его изменения, которые используют преимущества функционального программирования и "ленивость". Также это можно организовать по расписанию, если допустим нужно отслеживать изменения в JSON файлах. В UNIX-подобных операционных системах для этого используется специальная утилита cron.

\lstinline{cron} – программа-демон, предназначенная для выполнения заданий в определенное время, или через определенные промежутки времени. Для редактирования заданий используется утилита \lstinline{crontab}.

\Conc

В работе была рассмотрена идея метапрограммирования и поставлена задача генерации алгебраических типов данных. Также была разобрана работающая реализация задачи на функциональном языке программирования \lstinline{Haskell}. 

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
