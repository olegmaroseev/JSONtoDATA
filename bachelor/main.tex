% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\graphicspath{ {img/} }

\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\begin{document}

\Intro
В данной работе была реализована генерация алгебраических типов данных языка программирования Haskell 
по исходным данным в формате JSON.

В качестве основных инструментов для реализации поставленной задачи используются 
библиотека Data.Aeson~\cite{aeson} и расширение Template Haskell~\cite{tempHaskell}. Генерация 
производится с помощью рекурсивного прохода по абстрактному синтаксическому дереву (далее - AST) и 
накопление результатов обхода в монаде State ~\cite{stateM}.

Ключевыми моментами в реализации программы являются:

\begin{itemize}
  \item Получение AST по исходному JSON
  \item Преобразование AST в структруру для генерации алгебраического типа  
  \item Вклейка ("splicing") сгенерированного типа данных в код
\end{itemize}

\chapter{Предварительные сведения}

\section{JavaScript Object Notation}

JSON (\lstinline{JavaScript Object Notation})~\cite{jsonStandart} - простой формат обмена данными, основанный на подмножестве языка программирования JavaScript. При этом независим и может использоваться практически любым языком программирования. Файл в формате JSON представляет неупорядоченное множество пар ключ-значение, значения которого могут состоят из:  

\begin{itemize}
  \item Объектов (выделяются \{ ... \})
  \item Массивов (выделяются [ ... ])
  \item Строк
  \item Логических выражений (true|false)
  \item null-значений
\end{itemize}

\begin{ListingEnv}[H]
Пример данных в формате JSON:
\begin{Verb}
{     
    "firstName": "John",
    "lastName" : "Smith",
    "age" : 25
}
\end{Verb}
\caption{Пример данных в формате JSON}
\label{listing:jsonExample}
\end{ListingEnv}

Структуру хорошо можно выразить благодаря схемам, представленным на рисунках ~\ref{fig:objectGr}, ~\ref{fig:arrayGr} и ~\ref{fig:valueGr}.

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{object}
\caption{\label{fig:objectGr}Объект}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{array}
\caption{\label{fig:arrayGr}Массив}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{value}
\caption{\label{fig:valueGr}Значение}
\end{figure}

\section{Алгебраические типы данных}

Алгебраические типы данных (далее - АТД) - вид составных типов, представленных типом-произведением, типом-суммой, либо типом-суммой типов-произведений.~\cite{haskellGreatGood} Последний вариант хорошо илюстрируется примером двоичного дерева:

\begin{lstlisting}[language=Haskell]
data Tree a = Leaf a
          | Node (Tree a) (Tree a)
\end{lstlisting}

В примере \lstinline{Tree} является конструктором типа с одним типовым параметром. \lstinline{Leaf} и \lstinline{Node} - конструкторы значений. 

Также есть еще один вариант определения типа, называемый синтаксис записи с именованными полями:

\begin{lstlisting}[language=Haskell]
data Person = Person { firstName :: String
                       , lastName :: String
                       , age :: Int }
\end{lstlisting}

Вместо простого перечисления типов, мы создаем некую структуру и наполяем ее полями и их значениями. Главная выгода – такой синтаксис генерирует функции для извлечения полей. Также создается удобство чтения и понимая типа данных. Такие типы напоминают своей структурой \lstinline{JSON}-файлы. 

\section{Монада State}

Монада State применима, когда имеется некоторое состояние, которое мы постоянно изменяем. Cамое интересное, что при таком способе мы трансформируем состояние, но при этом не теряем "чистоту" функций. 

\subsection{Control.Monad.State}

Модуль Control.Monad.State~\cite{stateControl} определяет тип, оборачивающий вычисление с состоянием:

\begin{lstlisting}[language=Haskell]
newtype State s a = State {runState :: s -> (a,s) }
\end{lstlisting} 

Как видно из определения, вычисление в монаде State возвращает некоторый результат, при этом меняет состояние, при необходимости. Операции с состояними реализованы следующими функциями: \lstinline{get}(получает состояние) и \lstinline{put}(изменяет состояние на новое). В листинге~\ref{listing:stateGetPut} приведен простой пример, хорошо демонстрирующий возможности монады \lstinline{State}.

\begin{ListingEnv}[H]
\begin{Verb}
tick :: State Int Int
tick = do n <- get
	  put (n+1)
          return n

ghci> runState tick 3
(3,4)
\end{Verb}
\caption{Пример использования монады State}
\label{listing:stateGetPut}
\end{ListingEnv}

Также модуль содержит полезные функции для работы с состояниями. Самые важные представлены в листинге~\ref{listing:stateFunc}. Функции с постфиксом -State отличаются типом возвращаемого значения. Необходимое поведение можно выбрать исходя из сигнатуры.

\begin{ListingEnv}[H]
\begin{Verb}
modify :: MonadState s m => (s -> s) -> m ()

execState:: State s a -> s -> s

runState:: State s a -> s -> (a, s)

evalState:: State s a -> s -> a
\end{Verb}
\caption{Функции модуля Control.Monad.State}
\label{listing:stateFunc}
\end{ListingEnv}

Например, функция \lstinline{modify} преобразует внутреннее состояние функцией, которую получает на вход. Можно реализовать код листинга ~\ref{listing:stateGetPut} через \lstinline{modify} (листинг~\ref{listing:modifyState}).

\begin{ListingEnv}[H]
\begin{Verb}
tick :: State Int Int
tick = do modify (+1)
          return n

ghci> runState tick 3
(3,4)
\end{Verb}
\caption{Функция modify модуля Control.Monad.State}
\label{listing:modifyState}
\end{ListingEnv}
	
\section{Библиотека Data.Aeson}

\subsection{Общий способ}

Data.Aeson - библиотека для работы с файлами в формате JSON, написанная на языке Haskell. В библиотеке используются два основных класса типов - \lstinline{FromJSON} и \lstinline{ToJSON}.~\cite{aesonEx} Типы, имеющие возможность кодирования/декодирования, должны быть экземплярами классов FromJSON, ToJSON. Самый простой способ использования библиотеки - определить тип данных и экземпляры \lstinline{FromJSON}, \lstinline{ToJSON}. 

Существует возможность прописать экземпляры для кодирования/ декодирования по умолчанию, благодаря инструкции компилятора \lstinline{LANGUAGE} и экземпляру \lstinline{Generic}. Рассмотрим листинг~\ref{listing:genericData}, демонстрирующий данную возможность с условным типом данных 

\begin{ListingEnv}[H]
\begin{Verb}
instance ToJSON DataName

instance FromJSON DataName
\end{Verb}
\caption{Создание экземпляров по умолчанию}
\label{listing:genericData}
\end{ListingEnv}

Data.Aeson имеют свой собственный тип для представления конвертируемого JSON файла. Этот тип называется Value и имеет 6 конструкторов:

\begin{ListingEnv}[H]
\begin{Verb}
data Value
  = Object Object
  | Array Array
  | String Text
  | Number Scientific
  | Bool Bool
  | Null
\end{Verb}
\caption{Конструкторы Value}
\label{listing:value}
\end{ListingEnv}

\subsection{Работа с AST}

Aeson позволяет получить абстрактное синтаксическое дерево по JSON. Это бывает полезно, когда неизвестно какой тип данных 
соотвествует входному файлу. Имея AST, можно написать функцию для его обхода.~\cite{aesonEx}

В качестве примера рассмотрим получение AST для двух случаев: простой (листинг~\ref{listing:astGetSimple}) и более сложный со вложенными объектами (листинг~\ref{listing:astGetComp}).

\begin{ListingEnv}[H]
\begin{Verb}
decode :: FromJSON a => ByteString -> Maybe a

ghci> decode "{\"foo\": 123}" :: Maybe Value
Just (Object (fromList [("foo",Number 123)]))
\end{Verb}
\caption{JSON без вложенных объектов}
\label{listing:astGetSimple}
\end{ListingEnv}

\begin{ListingEnv}[H]
\begin{Verb}
ghci> decode "{\"foo\": [\"abc\",\"def\"]}" :: Maybe Value
Just (Object (fromList [("foo",Array (fromList [String "abc", 
                                               String "def"]))]))
\end{Verb}
\caption{JSON со вложенными объектами}
\label{listing:astGetComp}
\end{ListingEnv}

Помимо простого кодирования/декодирования JSON она также позволяет удобным образом писать сериализаторы и десериализаторы для произвольных типов.

\section{Template Haskell}

Template Haskell - это расширение языка Haskell, реализующее средства для метапрограммирования.~\cite{extensionHub} Оно позволяет использовать Haskell как язык управления и как управляемый язык. Так как работа ведется с расширением, то в исходник необходимо добавить директиву:

\begin{lstlisting}[language=Haskell]
{-# LANGUAGE TemplateHaskell #-}.
\end{lstlisting}

\subsection{Монада Q}

Монада \lstinline{Q} оборачивает Функция \lstinline{lift} поднимаеь

\subsection{Вклейка(splicing)}

Вклейка кода производится оператором  \$(...), который разворачивает шаблон с данным параметром в обычный Haskell код во время компиляции и вклеивает его на то же место. 

\subsection{Модуль Language.Haskell.TH.Syntax~\cite{coverHaskell}}

Тип \lstinline{Exp} определен в модуле Language.Haskell.TH.Syntax и представляет собой абстрактное синтаксическое дерево (AST) кода на Haskell.~\cite{thSyntax} \lstinline{Exp} имеет около 25 конструкторов значения. В листинге ~\ref{listing:expConstr} представлены только некоторые.  

\begin{ListingEnv}[H]
\begin{Verb}
data Exp
       = VarE Name
       | AppE Exp Exp
       | MultiIfE [(Guard, Exp)]
       | CondE Exp Exp Exp
       | ...
\end{Verb}
\caption{Конструкторы Exp}
\label{listing:expConstr}
\end{ListingEnv}

\chapter{Пример практического использования}

Git-репозиторий с исходным кодом на языке \lstinline{Haskell} доступен по адресу ~\cite{diploma}. 

\section{Простой пример}
Для начала будет рассмотрен простой пример. На вход программе подается простой \lstinline{JSON}, т.е. без вложенных объектов (листинг ~\ref{listing:json1}).

\begin{ListingEnv}[H]
\begin{Verb}
{
    "name" : "Joe",
    "age" : 25,
    "avg" : 4,
    "arr" : [1,2,3]
}
\end{Verb}
\label{listing:json1}
\end{ListingEnv}

В итоге мы получаем тип данных с именованными полями, полностью соответсвующий постановке задачи:

\begin{lstlisting}[language=Haskell]
data JSONData 
        = JSONData {arr :: [Float]
                    name :: String,
                    age :: Float,
                    avg :: Float}
          deriving (Show, Eq, Generic)
\end{lstlisting}

\section{Более сложный пример}

На вход программе подается \lstinline{JSON} со вложенным объектом. (Листинг ~\ref{listing:json2})  Интерес представляет то, как он будет представлен. 

\begin{ListingEnv}[H]
\begin{Verb}
{
    "name" : "Joe",
    "age" : 25,
    "avg" : 4,
    "arra" : 
             {
                 "fg" : "JSONTest"  
             }
}
\end{Verb}
\label{listing:json2}
\end{ListingEnv}

После выполнения программы мы получаем 2 типа данных, что полностью соответствует заявленным требованиям к программе. Первый тип в своем определении использует второй. 

\begin{lstlisting}[language=Haskell]
data JSONData
      = JSONData {name :: String,
                  arra :: Arra,
                  age :: Float,
                  avg :: Float}
        deriving (Show, Eq, Generic)

data Arra
      = Arra {fg :: String}
        deriving (Show, Eq, Generic)            
\end{lstlisting}




% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
