% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}
\graphicspath{ {img/} }

\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\begin{document}

\Intro
В данной работе была реализована генерация алгебраических типов данных языка программирования \lstinline{Haskell} 
по исходным данным в формате \lstinline{JSON}.

В качестве основных инструментов для реализации поставленной задачи используются 
библиотека \lstinline{Data.Aeson}~\cite{aeson} и расширение \lstinline{Template Haskell}~\cite{tempHaskell}. Генерация 
производится с помощью рекурсивного прохода по абстрактному синтаксическому дереву (далее - AST) и 
накопление результатов обхода в монаде \lstinline{State} ~\cite{stateM}.

Ключевыми моментами в реализации программы являются:

\begin{itemize}
  \item Получение AST по исходному \lstinline{JSON}
  \item Преобразование AST в структруру для генерации алгебраического типа  
  \item Вклейка ("splicing") сгенерированного типа данных в код
\end{itemize}

\chapter{Предварительные сведения}

\section{JavaScript Object Notation}

JSON (\lstinline{JavaScript Object Notation})~\cite{jsonStandart} - простой формат обмена данными, основанный на подмножестве языка программирования \lstinline{JavaScript}. При этом независим и может использоваться практически любым языком программирования. Файл в формате \lstinline{JSON} представляет неупорядоченное множество пар ключ-значение, значения которого могут состоят из:  

\begin{itemize}
  \item объектов (выделяются \{ ... \})
  \item массивов (выделяются [ ... ])
  \item строк
  \item логических выражений (true|false)
  \item null-значений
\end{itemize}

\begin{ListingEnv}[H]
Пример данных в формате JSON:
\begin{Verb}
{     
    "firstName": "John",
    "lastName" : "Smith",
    "age" : 25
}
\end{Verb}
\caption{Пример данных в формате JSON}
\label{listing:jsonExample}
\end{ListingEnv}

Структуру хорошо можно выразить по средствам схем, представленным на рисунках ~\ref{fig:objectGr}, ~\ref{fig:arrayGr} и ~\ref{fig:valueGr}.

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{object}
\caption{\label{fig:objectGr}Объект}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{array}
\caption{\label{fig:arrayGr}Массив}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{value}
\caption{\label{fig:valueGr}Значение}
\end{figure}

\section{Алгебраические типы данных}

Алгебраические типы данных (далее - АТД) - вид составных типов, представленных типом-произведением, типом-суммой, либо типом-суммой типов-произведений.~\cite{haskellGreatGood} Последний вариант хорошо илюстрируется примером двоичного дерева:

\begin{lstlisting}[language=Haskell]
data Tree a = Leaf a
          | Node (Tree a) (Tree a)
\end{lstlisting}

В примере \lstinline{Tree} является конструктором типа с одним типовым параметром. \lstinline{Leaf} и \lstinline{Node} - конструкторы значений. 

Также есть еще один вариант определения типа, называемый синтаксис записи с именованными полями:

\begin{lstlisting}[language=Haskell]
data Person = Person { firstName :: String
                       , lastName :: String
                       , age :: Int }
\end{lstlisting}

Вместо простого перечисления типов, мы создаем некую структуру и наполяем ее полями и их значениями. Главная выгода – такой синтаксис генерирует функции для извлечения полей. Также создается удобство чтения и понимая типа данных. Такие типы напоминают своей структурой \lstinline{JSON}-файлы. 

\section{Монада State}

Монада \lstinline{State} применима, когда имеется некоторое состояние, которое мы постоянно изменяем. Cамое интересное, что при таком способе мы трансформируем состояние, но при этом не теряем "чистоту" функций. 

\subsection{Control.Monad.State}

Модуль Control.Monad.State~\cite{stateControl} определяет тип, оборачивающий вычисление с состоянием:

\begin{lstlisting}[language=Haskell]
newtype State s a = State {runState :: s -> (a,s) }
\end{lstlisting} 

Как видно из определения, вычисление в монаде State возвращает некоторый результат, при этом меняет состояние, при необходимости. Операции с состояними реализованы следующими функциями: \lstinline{get}(получает состояние) и \lstinline{put}(изменяет состояние на новое). В листинге~\ref{listing:stateGetPut} приведен простой пример, хорошо демонстрирующий возможности монады \lstinline{State}.

\begin{ListingEnv}[H]
\begin{Verb}
tick :: State Int Int
tick = do n <- get
	  put (n+1)
          return n

ghci> runState tick 3
(3,4)
\end{Verb}
\caption{Пример использования монады State}
\label{listing:stateGetPut}
\end{ListingEnv}

Также модуль содержит полезные функции для работы с состояниями. Самые важные представлены в листинге~\ref{listing:stateFunc}. Функции с постфиксом -State отличаются типом возвращаемого значения. Необходимое поведение можно выбрать исходя из сигнатуры.

\begin{ListingEnv}[H]
\begin{Verb}
modify :: MonadState s m => (s -> s) -> m ()

execState:: State s a -> s -> s

runState:: State s a -> s -> (a, s)

evalState:: State s a -> s -> a
\end{Verb}
\caption{Функции модуля Control.Monad.State}
\label{listing:stateFunc}
\end{ListingEnv}

Например, функция \lstinline{modify} преобразует внутреннее состояние функцией, которую получает на вход. Можно реализовать код листинга ~\ref{listing:stateGetPut} через \lstinline{modify} (листинг~\ref{listing:modifyState}).

\begin{ListingEnv}[H]
\begin{Verb}
tick :: State Int Int
tick = do modify (+1)
          return n

ghci> runState tick 3
(3,4)
\end{Verb}
\caption{Функция modify модуля Control.Monad.State}
\label{listing:modifyState}
\end{ListingEnv}
	
\section{Библиотека Data.Aeson}

\subsection{Общий способ}

\lstinline{Data.Aeson} - библиотека для работы с файлами в формате \lstinline{JSON}, написанная на языке \lstinline{Haskell}. В библиотеке используются два основных класса типов - \lstinline{FromJSON} и \lstinline{ToJSON}.~\cite{aesonEx} Типы, имеющие возможность кодирования/декодирования, должны быть экземплярами классов \lstinline{FromJSON}, \lstinline{ToJSON}. Самый простой способ использования библиотеки - определить тип данных и экземпляры \lstinline{FromJSON}, \lstinline{ToJSON}. 

Существует возможность прописать экземпляры для кодирования/ декодирования по умолчанию, благодаря инструкции компилятора \lstinline{LANGUAGE} и экземпляру \lstinline{Generic}. Рассмотрим листинг~\ref{listing:genericData}, демонстрирующий данную возможность с условным типом данных 

\begin{ListingEnv}[H]
\begin{Verb}
instance ToJSON DataName

instance FromJSON DataName
\end{Verb}
\caption{Создание экземпляров по умолчанию}
\label{listing:genericData}
\end{ListingEnv}

\lstinline{Data.Aeson} имеет свой собственный тип для представления конвертируемого \lstinline{JSON}-файла. Этот тип называется \lstinline{Value} и имеет 6 конструкторов значения:

\begin{ListingEnv}[H]
\begin{Verb}
data Value
  = Object Object
  | Array Array
  | String Text
  | Number Scientific
  | Bool Bool
  | Null
\end{Verb}
\caption{Конструкторы Value}
\label{listing:value}
\end{ListingEnv}

\subsection{Работа с AST}

\lstinline{Aeson} позволяет получить абстрактное синтаксическое дерево по \lstinline{JSON}. Это бывает полезно, когда неизвестно какой тип данных 
соотвествует входному файлу. Имея AST, можно написать функцию для его обхода.~\cite{aesonEx}

В качестве примера рассмотрим получение AST для двух случаев: простой (листинг~\ref{listing:astGetSimple}) и более сложный со вложенными объектами (листинг~\ref{listing:astGetComp}).

\begin{ListingEnv}[H]
\begin{Verb}
decode :: FromJSON a => ByteString -> Maybe a

ghci> decode "{\"foo\": 123}" :: Maybe Value
Just (Object (fromList [("foo",Number 123)]))
\end{Verb}
\caption{JSON без вложенных объектов}
\label{listing:astGetSimple}
\end{ListingEnv}

\begin{ListingEnv}[H]
\begin{Verb}
ghci> decode "{\"foo\": [\"abc\",\"def\"]}" :: Maybe Value
Just (Object (fromList [("foo",Array (fromList [String "abc", 
                                               String "def"]))]))
\end{Verb}
\caption{JSON со вложенными объектами}
\label{listing:astGetComp}
\end{ListingEnv}

Помимо простого кодирования/декодирования \lstinline{JSON} она также позволяет удобным образом писать сериализаторы и десериализаторы для произвольных типов.

\section{Template Haskell}

\lstinline{Template Haskell} - это расширение языка \lstinline{Haskell}, реализующее средства для метапрограммирования.~\cite{extensionHub} Оно позволяет использовать Haskell как язык управления и как управляемый язык. Так как работа ведется с расширением, то в исходник необходимо добавить директиву:

\begin{lstlisting}[language=Haskell]
{-# LANGUAGE TemplateHaskell #-}.
\end{lstlisting}

\subsection{Монада Q}

Монада \lstinline{Q} оборачивает значения типов, предназначенных для последующей генерации других конструкций на языке \lstinline{Haskell}. Такие типы полностью удовлетворяют синтаксису языка и представляет собой абстрактное синтаксическое дерево кода: тип \lstinline{Exp} для генерации выражений, \lstinline{Dec} - для объявлений, \lstinline{Lit} - для литералов и т.д.~\cite{thSyntax}

\subsection{Модуль Language.Haskell.TH.Syntax}

Модуль Language.Haskell.TH.Syntax

Тип \lstinline{Exp} определен в модуле \lstinline{Language.Haskell.TH.Syntax}~\cite{coverHaskell} и  \lstinline{Exp} имеет около 25 конструкторов значения. В листинге ~\ref{listing:expConstr} представлены только некоторые.  

\begin{ListingEnv}[H]
\begin{Verb}
data Exp
       = VarE Name
       | AppE Exp Exp
       | MultiIfE [(Guard, Exp)]
       | CondE Exp Exp Exp
       | ...
\end{Verb}
\caption{Конструкторы Exp}
\label{listing:expConstr}
\end{ListingEnv}

\subsection{Вклейка(splicing)}

Вклейка кода производится оператором  \lstinline{\$(...)}, который разворачивает шаблон с данным параметром в обычный \lstinline{Haskell} код во время компиляции и вклеивает его на то же место. Важно, чтобы между скобками и оператором \lstinline{\$} не было пробелов. Также есть ограничение по использованию вклейки: ее можно использовать только из другого модуля, т.е. нельзя в одном модуле прописать шаблон и сразу же его использовать.

Вклейка может использоваться в:

\begin{itemize}
  \item выражениях (выражение должно иметь тип Q Exp)
  \item объявлениях верхнего уровня (выражение должно иметь тип Q [Dec])
  \item типах (выражение должно иметь тип Q Type)
\end{itemize}

\chapter{Пример практического использования}

Git-репозиторий с исходным кодом на языке \lstinline{Haskell} доступен по адресу ~\cite{diploma}. 

\section{Отладка программ в GHC}

Компилятор \lstinline{GHC} предоставляет мощные инструменты для отладки программы. ~\cite{debugGHC} Например, можно ставить контрольные точки, получать подробное описание ошибок, генерировать полезные структуры, смотреть на AST и т.д. Для этого используются флаги компилятору. 

Полезным флагом для программы, использующей \lstinline{Template Haskell} служит \lstinline{-ddump-splices}. Его средствами организован вывод полученного из шаблона выражения, либо ошибки (информативное сообщение).

\begin{ListingEnv}[H]
\begin{Verb}
on.hs:8:3-17: Splicing declarations
    getDataFromJSON
  ======>
    data JSONData
      = JSONData {name :: String}
      deriving (Generic, Show, Eq)
\end{Verb}
\caption{Запуск отладчика с флагом -ddump-splices}
\end{ListingEnv}

\section{Простой пример}
Для начала будет рассмотрен простой пример. На вход программе подается простой \lstinline{JSON}, т.е. без вложенных объектов (листинг ~\ref{listing:json1}).

\begin{ListingEnv}[H]
\begin{Verb}
{
    "name" : "Joe",
    "age" : 25,
    "avg" : 4,
    "arr" : [1,2,3]
}
\end{Verb}
\label{listing:json1}
\end{ListingEnv}

В итоге мы получаем тип данных с именованными полями, полностью соответсвующий постановке задачи:

\begin{lstlisting}[language=Haskell]
data JSONData 
        = JSONData {arr :: [Float]
                    name :: String,
                    age :: Float,
                    avg :: Float}
          deriving (Show, Eq, Generic)
\end{lstlisting}

\section{Более сложный пример}

На вход программе подается \lstinline{JSON} со вложенным объектом. (Листинг ~\ref{listing:json2})  Интерес представляет то, как он будет представлен. 

\begin{ListingEnv}[H]
\begin{Verb}
{
    "name" : "Joe",
    "age" : 25,
    "avg" : 4,
    "arra" : 
             {
                 "fg" : "JSONTest"  
             }
}
\end{Verb}
\label{listing:json2}
\end{ListingEnv}

После выполнения программы мы получаем 2 типа данных, что полностью соответствует заявленным требованиям к программе. Первый тип в своем определении использует второй. 

\begin{lstlisting}[language=Haskell]
data JSONData
      = JSONData {name :: String,
                  arra :: Arra,
                  age :: Float,
                  avg :: Float}
        deriving (Show, Eq, Generic)

data Arra
      = Arra {fg :: String}
        deriving (Show, Eq, Generic)            
\end{lstlisting}

% Печать списка литературы (библиографии)
\printbibliography[%{}
    heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\end{document}
